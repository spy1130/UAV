作用域：
1、普通局部变量
a)属于某个{}，在{}外部不能使用此变量，在{}内部是可以使用
b)执行到普通局部变量定义语句，才会分配空间，离开{}，自动释放
c)普通局部变量不初始化，默认值为随机数
	{
		int a; 
		if(1)
		{
			a = 10;
			if(1)
			{
				a = 11;
			}
		}
	}
	
	a = 10; //err
	
2、static局部变量
a)属于某个{}，在{}外部不能使用此变量，在{}内部是可以使用
b)在编译阶段就已经分配空间，初始化只能使用常量
c)static局部变量不初始化，默认值为0
d)离开{}，static局部变量不会释放，只有整个程序结束才释放
void fun()
{
	int i = 0;
	i++;
	printf("i = %d\n", i);
}

void static_fun()
{
	static int i = 0; //只会初始化一次
	i++;
	printf("i = %d\n", i);
}

fun(); //1
fun(); //1

static_fun(); //1
static_fun(); //2

3、普通全局变量
1）在编译阶段分配空间，只有整个程序结束才释放
2）普通全局变量只要定义了，任何地方都能使用，使用前需要声明
3）所有的.c文件，只能定义一次普通全局变量，但是可以声明多次（外部链接）

分文件使用普通全局变量
xxx.h（普通全局变量的声明）
extern int a;

xxx.c（普通全局变量的定义）
int a = 0;

4、static全局变量
1）在编译阶段分配空间，只有整个程序结束才释放
2）static全局变量只能在定义所在的文件中使用此变量（内部链接）
3）不同的.c文件，可以定义一次static全局变量

5、extern函数和static函数的区别（作用域）
1）extern函数所有文件都是调用，所有文件只能出现一次extern函数定义
2）static函数只能在定义所在的文件中调用此函数，不同文件，可以定义一次static函数

内存布局：
1、程序没有运行前（除了堆区和栈区）：
text(代码区)：函数，只读
data(数据区)：初始化的数据：全局变量，static变量，文字常量（只读）
bss：未初始化的数据：全局变量，static变量

2、程序运行，加载内存，多了堆区和栈区：
text(代码区)：函数，只读
data(数据区)：初始化的数据：全局变量，static变量，文字常量（只读）
bss：未初始化的数据：全局变量，static变量
heap(堆区)：由用户手动申请和释放(malloc, free)
stack(栈区)：程序自动申请空间自动释放，非static局部变量

3、内存操作函数
int a[10];
memset(a, 0, sizeof(a));
memset(a, 0, 10 * sizeof(int));

int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int b[10];
memcpy(b, a, 10*sizeof(int) ); //最好不要出现内存重叠
memmove(b, a, 10*sizeof(int) ); //可以出现内存重叠

memcmp(a, b, 5*sizeof(int));
=0
>0
<0

4、堆区空间使用
a)栈区空间
//普通变量
int *p = NULL;
int a = 10;
p = &a; //p指向a的内存，栈区空间
*p = 100; //*p就是a，间接给a赋值

//栈区数组
int *p = NULL;
int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
p = a;    //指针和数组建立关系
p = &a[0];

//操作指针所指向的内存
p[0] = 1;
*(p+0) = 1;

b)堆区空间

//一个元素
int *p = NULL;

//malloc的返回值就是堆区的首地址
p = (int *)malloc( sizeof(int) );
*p = 100; //*p就是堆区内存
printf("*p = %d\n", *p);

//释放p所指向的内存，但是p的值没有改变
//同一个内存不能释放多次
free(p);
p = NULL;

//堆区数组
int *p = NULL;
p = (int *)malloc(10 * sizeof(int) );
p[0] = 1;
*(p+0) = 1;

free(p);
p = NULL;

内存泄露：动态分配空间，没有释放
内存污染：操作野指针所指向内存，堆区越界




